#page-profile
  = render ViewComponents::Profile::Header.new(@user, @profile, :summary)

  %article
    %section.contributions-section
      .info
      .chart-container
        / This will be the same data hash as the LHS.
        / For one the languages/categories.
        #label-0.label
          = graphical_icon :maintaining, hex: true
          .title Publishing
          .subtitle 78 solutions
          .tag.top-10 Top 10%
        #label-1.label
          = graphical_icon :mentoring, hex: true
          .title Mentoring
          .subtitle 520 students
          .tag.top-1 Top 1%
        #label-2.label
          = graphical_icon :concepts, hex: true
          .title Authoring
          .subtitle 8 exercises
        #label-3.label
          = graphical_icon :maintaining, hex: true
          .title Building
          .subtitle 5,123 PRs merged
          .tag.top-3 Top 3%
        #label-4.label
          = graphical_icon :maintaining, hex: true
          .title Maintaining
          .subtitle 2,193 PRs reviews
        #label-5.label
          = graphical_icon :maintaining, hex: true
          .title Other

        .chart
          %canvas#contributions-chart

      <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
      :javascript
        // The dataset needs to change based on which thing is selected on the dropdown on the LHS
        // There is a set of data for the "All category" (commented out) then there is a set
        // for each track, which is powered by CSS variables. All you need to change when you do
        // this is set the actual 6 values in the data array. Everything else should be exactly as below.

        // This is the correct data (and helper function) for the "All" category
        function createBluePurpleGradient(chart, opacity) {
          const {ctx, chartArea} = chart;
          if (!chartArea) { return null; }
          const gradient = ctx.createLinearGradient(0, chartArea.bottom, 0, chartArea.top);
          gradient.addColorStop(0, `rgba(34, 0, 255, ${opacity})`);
          gradient.addColorStop(1, `rgba(158, 0, 255, ${opacity})`);
          return gradient
        }
        /*const data = {
          labels: [ '', '', '', '', '', '' ],
          datasets: [{
            label: '',
            data: [65, 59, 90, 81, 56, 55],
            fill: true,
            backgroundColor: function(context) { return createBluePurpleGradient(context.chart, 0.3) },
            borderColor: function(context) { return createBluePurpleGradient(context.chart, 1) },
            pointBorderColor: function(context) { return createBluePurpleGradient(context.chart, 1) },
            pointBackgroundColor: function(context) { return createBluePurpleGradient(context.chart, 1) },
            pointBorderColor: '#fff',
            pointHoverBackgroundColor: function(context) { return createBluePurpleGradient(context.chart, 1) },
            pointHoverBorderColor: function(context) { return createBluePurpleGradient(context.chart, 1) },
            pointRadius: 5,
            pointHoverRadius: 5
          }]
        };*/

        // This is the correct data for a specific track.
        // Each of the colors is based on a CSS Variable
        // You should be able to get them using the correct slug.
        // Currently ruby, elixir and csharp work.
        // They then get interpolated into the strings below.
        const trackColor = getComputedStyle(document.documentElement).getPropertyValue('--track-color-ruby');
        const data = {
          labels: [ '', '', '', '', '', '' ],
          datasets: [{
            label: '',
            data: [65, 59, 90, 81, 56, 55],
            fill: true,
            backgroundColor: `rgba(${trackColor}, 0.3)`,
            borderColor: `rgba(${trackColor}, 1)`,
            pointBorderColor: `rgba(${trackColor}, 1)`,
            pointBackgroundColor: `rgba(${trackColor}, 1)`,
            pointBorderColor: '#fff',
            pointHoverBackgroundColor: `rgba(${trackColor}, 1)`,
            pointHoverBorderColor: `rgba(${trackColor}, 1)`,
            pointRadius: 5,
            pointHoverRadius: 5
          }]
        };

        const config = {
          type: 'radar',
          data: data,
          options: {
            aspectRatio: 1,
            elements: {
              line: { borderWidth: 3 }
            },
            scales: {
              r: {
                beginAtZero: true,
                ticks: { display:false, color: "red" },
                angleLines: { color: "#D5D8E4" },
                grid: { color:"#D5D8E4" }
              }
            },
            plugins: {
              legend: { display: false },
              tooltip: { enabled: false }
            }
          },
        };

        // The does the actual rendering of the chart
        var ctx = document.getElementById('contributions-chart');
        var chart = new Chart(ctx, config)

        // This whole next bit is for correctly positioning the labels around the chart.
        // It is really important that the chart and the labels have rendered before this code below is
        // run. When they render they do so invisibly, and then their sizes are used to
        // calculated the values below, so you'll need to do a second pain (setTimeout(..., 0))
        // where this bit gets run after the initial pass.
        const leftMargin = 100;
        const topMargin = 150;
        const buffer = 8;
        const containerHeight = ctx.parentNode.offsetHeight

        // Each of the the left/right/bottom/top/margin lines is specific to the label so
        // don't generalise those, but the first two lines and the visiblity one can
        // be safely DRY'd up.
        const point0 = chart.getDatasetMeta(0).iScale.getPointLabelPosition(0)
        const label0 = document.getElementById("label-0")
        label0.style.left = ((point0.left + leftMargin) + "px")
        label0.style.marginLeft = (-(label0.offsetWidth / 2) + "px")
        label0.style.bottom = ((containerHeight - point0.bottom + topMargin) + "px")
        label0.style.visibility = "visible"

        const point1 = chart.getDatasetMeta(0).iScale.getPointLabelPosition(1)
        const label1 = document.getElementById("label-1")
        label1.style.left = ((point1.left + leftMargin + buffer) + "px")
        label1.style.bottom = ((containerHeight - point1.bottom + topMargin - (label1.offsetHeight / 2)) + "px")
        label1.style.visibility = "visible"

        const point2 = chart.getDatasetMeta(0).iScale.getPointLabelPosition(2)
        const label2 = document.getElementById("label-2")
        label2.style.left = ((point2.left + leftMargin + buffer) + "px")
        label2.style.bottom = ((containerHeight - point2.bottom + topMargin - (label2.offsetHeight / 2)) + "px")
        label2.style.visibility = "visible"

        const point3 = chart.getDatasetMeta(0).iScale.getPointLabelPosition(3)
        const label3 = document.getElementById("label-3")
        label3.style.left = ((point3.left + leftMargin) + "px")
        label3.style.marginLeft = (-(label3.offsetWidth / 2) + "px")
        label3.style.bottom = ((containerHeight - point3.bottom + topMargin - label3.offsetHeight) + "px")
        label3.style.visibility = "visible"

        const point4 = chart.getDatasetMeta(0).iScale.getPointLabelPosition(4)
        const label4 = document.getElementById("label-4")
        label4.style.left = ((point4.left + leftMargin - label4.offsetWidth - buffer) + "px")
        label4.style.bottom = ((containerHeight - point4.bottom + topMargin - (label4.offsetHeight / 2)) + "px")
        label4.style.visibility = "visible"

        const point5 = chart.getDatasetMeta(0).iScale.getPointLabelPosition(5)
        const label5 = document.getElementById("label-5")
        label5.style.left = ((point5.left + leftMargin - label5.offsetWidth - buffer) + "px")
        label5.style.bottom = ((containerHeight - point5.bottom + topMargin - (label5.offsetHeight / 2)) + "px")
        label5.style.visibility = "visible"


    %section.published-solutions-section
      .lg-container.container
        %header.section-header
          = graphical_icon :'community-solutions', hex: true
          %h2 Published Solutions
          .total-count= @num_total_solutions
          %hr.c-divider

        .solutions
          - @solutions.each do |solution|
            = render ReactComponents::Common::CommunitySolution.new(solution, context: :profile)

        - if @profile.solutions_tab?
          = render ViewComponents::ProminentLink.new("See all of #{@user.name}'s solutions", "#")

    = render ReactComponents::Profile::TestimonialsSummary.new(@user, @profile)
