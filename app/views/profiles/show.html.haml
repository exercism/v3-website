#page-profile
  = render ViewComponents::Profile::Header.new(@user, @profile, :summary)


  %article
    / This is the component to build off
    = render ReactComponents::Profile::ContributionsSummary.new(@user)

    / This is a temporary call to show you the data to work off
    / It shows how you use the data in the ReactComponent Helper
    - data = ReactComponents::Profile::ContributionsSummary.new(@user).data

    / You either want :all (default) or one of the tracks, which would be:
    / data['tracks'][0]['slug'] => Ruby
    / data['tracks'][0]['categories'] => (same structure as data["all"])
    - publishing_data = data[:all].find{|s|s[:id] == :publishing}
    - mentoring_data = data[:all].find{|s|s[:id] == :mentoring}
    - authoring_data = data[:all].find{|s|s[:id] == :authoring}
    - building_data = data[:all].find{|s|s[:id] == :building}
    - maintaining_data = data[:all].find{|s|s[:id] == :maintaining}
    - other_data = data[:all].find{|s|s[:id] == :other}

    / In React we need to create the actual chart array
    / We have a min_reputation which is the max / 15. This just makes the chart look good.
    / The we put the values in the order as below and it all magically works ;)
    - max_reputation = data[:all].map {|cat|cat[:reputation]}.sum
    - min_reputation = max_reputation / 15.0

    - chart_data = []
    - chart_data << (publishing_data[:reputation] > min_reputation ? publishing_data[:reputation] : min_reputation)
    - chart_data << (mentoring_data[:reputation] > min_reputation ? mentoring_data[:reputation] : min_reputation)
    - chart_data << (authoring_data[:reputation] > min_reputation ? authoring_data[:reputation] : min_reputation)
    - chart_data << (building_data[:reputation] > min_reputation ? building_data[:reputation] : min_reputation)
    - chart_data << (maintaining_data[:reputation] > min_reputation ? maintaining_data[:reputation] : min_reputation)
    - chart_data << (other_data[:reputation] > min_reputation ? other_data[:reputation] : min_reputation)

    / And this is what it should look like
    %section.contributions-section
      .info
      .chart-container
        / This will be the same data hash as the LHS.
        / For one the languages/categories.
        #label-0.label
          = graphical_icon :maintaining, hex: true
          .title Publishing
          .subtitle= publishing_data[:metric]
          .tag.top-10 Top 10%
        #label-1.label
          = graphical_icon :mentoring, hex: true
          .title Mentoring
          .subtitle= mentoring_data[:metric]
          .tag.top-1 Top 1%
        #label-2.label
          = graphical_icon :concepts, hex: true
          .title Authoring
          .subtitle= authoring_data[:metric]
        #label-3.label
          = graphical_icon :maintaining, hex: true
          .title Building
          .subtitle= building_data[:metric]
          .tag.top-3 Top 3%
        #label-4.label
          = graphical_icon :maintaining, hex: true
          .title Maintaining
          .subtitle= maintaining_data[:metric]
        #label-5.label
          = graphical_icon :maintaining, hex: true
          .title Other

        .chart
          %canvas#contributions-chart

      <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
      :javascript
        // The dataset needs to change based on which thing is selected on the dropdown on the LHS
        // There is a set of data for the "All category" (commented out) then there is a set
        // for each track, which is powered by CSS variables. All you need to change when you do
        // this is set the actual 6 values in the data array. Everything else should be exactly as below.

        // This is the correct data (and helper function) for the "All" category
        function createBluePurpleGradient(chart, opacity) {
          const {ctx, chartArea} = chart;
          if (!chartArea) { return null; }
          const gradient = ctx.createLinearGradient(0, chartArea.bottom, 0, chartArea.top);
          gradient.addColorStop(0, `rgba(34, 0, 255, ${opacity})`);
          gradient.addColorStop(1, `rgba(158, 0, 255, ${opacity})`);
          return gradient
        }
        /*const data = {
          labels: [ '', '', '', '', '', '' ],
          datasets: [{
            label: '',
            data: [65, 59, 90, 81, 56, 55],
            fill: true,
            backgroundColor: function(context) { return createBluePurpleGradient(context.chart, 0.3) },
            borderColor: function(context) { return createBluePurpleGradient(context.chart, 1) },
            pointBorderColor: function(context) { return createBluePurpleGradient(context.chart, 1) },
            pointBackgroundColor: function(context) { return createBluePurpleGradient(context.chart, 1) },
            pointBorderColor: '#fff',
            pointHoverBackgroundColor: function(context) { return createBluePurpleGradient(context.chart, 1) },
            pointHoverBorderColor: function(context) { return createBluePurpleGradient(context.chart, 1) },
            pointRadius: 5,
            pointHoverRadius: 5
          }]
        };*/

        // This is the correct data for a specific track.
        // Each of the colors is based on a CSS Variable
        // You should be able to get them using the correct slug.
        // Currently ruby, elixir and csharp work.
        // They then get interpolated into the strings below.
        const trackColor = getComputedStyle(document.documentElement).getPropertyValue('--track-color-ruby');
        const data = {
          labels: [ '', '', '', '', '', '' ],
          datasets: [{
            label: '',
            data: #{chart_data.to_json},
            fill: true,
            backgroundColor: `rgba(${trackColor}, 0.3)`,
            borderColor: `rgba(${trackColor}, 1)`,
            pointBorderColor: `rgba(${trackColor}, 1)`,
            pointBackgroundColor: `rgba(${trackColor}, 1)`,
            pointBorderColor: '#fff',
            pointHoverBackgroundColor: `rgba(${trackColor}, 1)`,
            pointHoverBorderColor: `rgba(${trackColor}, 1)`,
            pointRadius: 5,
            pointHoverRadius: 5
          }]
        };

        const config = {
          type: 'radar',
          data: data,
          options: {
            aspectRatio: 1,
            elements: {
              line: { borderWidth: 3 }
            },
            scales: {
              r: {
                beginAtZero: true,
                ticks: { display:false, color: "red" },
                angleLines: { color: "#D5D8E4" },
                grid: { color:"#D5D8E4" }
              }
            },
            plugins: {
              legend: { display: false },
              tooltip: { enabled: true }
            }
          },
        };

        // The does the actual rendering of the chart
        var ctx = document.getElementById('contributions-chart');
        var chart = new Chart(ctx, config)

        // This whole next bit is for correctly positioning the labels around the chart.
        // It is really important that the chart and the labels have rendered before this code below is
        // run. When they render they do so invisibly, and then their sizes are used to
        // calculated the values below, so you'll need to do a second pain (setTimeout(..., 0))
        // where this bit gets run after the initial pass.
        const leftMargin = 100;
        const topMargin = 150;
        const buffer = 8;
        const containerHeight = ctx.parentNode.offsetHeight

        // Each of the the left/right/bottom/top/margin lines is specific to the label so
        // don't generalise those, but the first two lines and the visiblity one can
        // be safely DRY'd up.
        const point0 = chart.getDatasetMeta(0).iScale.getPointLabelPosition(0)
        const label0 = document.getElementById("label-0")
        label0.style.left = ((point0.left + leftMargin) + "px")
        label0.style.marginLeft = (-(label0.offsetWidth / 2) + "px")
        label0.style.bottom = ((containerHeight - point0.bottom + topMargin) + "px")
        label0.style.visibility = "visible"

        const point1 = chart.getDatasetMeta(0).iScale.getPointLabelPosition(1)
        const label1 = document.getElementById("label-1")
        label1.style.left = ((point1.left + leftMargin + buffer) + "px")
        label1.style.bottom = ((containerHeight - point1.bottom + topMargin - (label1.offsetHeight / 2)) + "px")
        label1.style.visibility = "visible"

        const point2 = chart.getDatasetMeta(0).iScale.getPointLabelPosition(2)
        const label2 = document.getElementById("label-2")
        label2.style.left = ((point2.left + leftMargin + buffer) + "px")
        label2.style.bottom = ((containerHeight - point2.bottom + topMargin - (label2.offsetHeight / 2)) + "px")
        label2.style.visibility = "visible"

        const point3 = chart.getDatasetMeta(0).iScale.getPointLabelPosition(3)
        const label3 = document.getElementById("label-3")
        label3.style.left = ((point3.left + leftMargin) + "px")
        label3.style.marginLeft = (-(label3.offsetWidth / 2) + "px")
        label3.style.bottom = ((containerHeight - point3.bottom + topMargin - label3.offsetHeight) + "px")
        label3.style.visibility = "visible"

        const point4 = chart.getDatasetMeta(0).iScale.getPointLabelPosition(4)
        const label4 = document.getElementById("label-4")
        label4.style.left = ((point4.left + leftMargin - label4.offsetWidth - buffer) + "px")
        label4.style.bottom = ((containerHeight - point4.bottom + topMargin - (label4.offsetHeight / 2)) + "px")
        label4.style.visibility = "visible"

        const point5 = chart.getDatasetMeta(0).iScale.getPointLabelPosition(5)
        const label5 = document.getElementById("label-5")
        label5.style.left = ((point5.left + leftMargin - label5.offsetWidth - buffer) + "px")
        label5.style.bottom = ((containerHeight - point5.bottom + topMargin - (label5.offsetHeight / 2)) + "px")
        label5.style.visibility = "visible"


    %section.published-solutions-section
      .lg-container.container
        %header.section-header
          = graphical_icon :'community-solutions', hex: true
          %h2 Published Solutions
          .total-count= @num_total_solutions
          %hr.c-divider

        .solutions
          - @solutions.each do |solution|
            = render ReactComponents::Common::CommunitySolution.new(solution, context: :profile)

        - if @profile.solutions_tab?
          = render ViewComponents::ProminentLink.new("See all of #{@user.name}'s solutions", "#")

    = render ReactComponents::Profile::TestimonialsSummary.new(@user, @profile)
